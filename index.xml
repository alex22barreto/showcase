<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Showcase Template</title><link>https://visualcomputing.github.io/showcase/</link><description>Recent content in Introduction on Showcase Template</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://visualcomputing.github.io/showcase/index.xml" rel="self" type="application/rss+xml"/><item><title>Creating a New Theme</title><link>https://visualcomputing.github.io/showcase/posts/creating-a-new-theme/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/posts/creating-a-new-theme/</guid><description>Introduction # This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description></item><item><title>Migrate to Hugo from Jekyll</title><link>https://visualcomputing.github.io/showcase/posts/migrate-from-jekyll/</link><pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/posts/migrate-from-jekyll/</guid><description>Move static content to static # Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description></item><item><title>(Hu)go Template Primer</title><link>https://visualcomputing.github.io/showcase/posts/goisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/posts/goisforlovers/</guid><description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description></item><item><title>Getting Started with Hugo</title><link>https://visualcomputing.github.io/showcase/posts/hugoisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/posts/hugoisforlovers/</guid><description>Step 1. Install Hugo # Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs # Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Alex-Jose-Alberto-Barreto-Cajica/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Alex-Jose-Alberto-Barreto-Cajica/</guid><description>Alex Jose Alberto Barreto Cajica # Interests # Desarrollo de software, computacion en la nube, Big Data, BlockChain.
Contacto # aabarretoc@unal.edu.co</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Alex-Barreto-Taller-3/imageProcessingAB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Alex-Barreto-Taller-3/imageProcessingAB/</guid><description>Procesamiento digital de imágenes # El procesamiento de imágenes digitales es el conjunto de técnicas que se aplican a las imágenes digitales con el objetivo de mejorar la calidad o facilitar la búsqueda de información.
Proceso de filtrado # Es el conjunto de técnicas englobadas dentro del preprocesamiento de imágenes cuyo objetivo fundamental es obtener, a partir de una imagen origen, otra final cuyo resultado sea más adecuado para una aplicación específica mejorando ciertas características de la misma que posibilite efectuar operaciones del procesado sobre ella.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Alex-Barreto-Taller-3/proceduralTexturingAB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Alex-Barreto-Taller-3/proceduralTexturingAB/</guid><description>Textura de procedimiento # En gráficos por computadora , una textura de procedimiento es una textura creada utilizando una descripción matemática (es decir, un algoritmo ) en lugar de datos almacenados directamente. La ventaja de este enfoque es el bajo costo de almacenamiento, la resolución ilimitada de texturas y el fácil mapeo de texturas.
Este tipo de texturas se utilizan a menudo para modelar superficies o representaciones volumétricas de elementos naturales como madera , mármol , granito , metal , piedra y otros.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Alex-Barreto-Taller-3/ShadersColoring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Alex-Barreto-Taller-3/ShadersColoring/</guid><description> Shaders coloring # Intoduction # Context # Results # p5-iframe markdown Texture 1 # Conclusions and Future work #</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Alex-Barreto-Taller-3/texturing3d/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Alex-Barreto-Taller-3/texturing3d/</guid><description>Texturizado y coloreado # Mapeo UV # El texturizado UV permite que los polígonos que componen un objeto 3D se pinten con color (y otros atributos de la superficie) de una imagen normal.
Resultados # Puede usar el primer control deslizante para ajustar la intensidad del color en el canal R del modelo RGB.
uv.js let easycam; let uvShader; let colorR; function preload() { // see: https://github.com/VisualComputing/p5.treegl#handling uvShader = readShader(&amp;#39;/showcase/sketches/shaders/uv.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Kevin-Leonardo-Alvarez-Mora/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Kevin-Leonardo-Alvarez-Mora/</guid><description>Kevin Leonardo Alvarez Mora # Interests # Web development, Cybersecurity, Data Science
Contacto # klalvarezm@unal.edu.co</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Kevin-Alvarez-taller-3/Image-Processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Kevin-Alvarez-taller-3/Image-Processing/</guid><description>Image Processing # Background # We can use a different set of algorithms to process (modify, transform) and image, in this case, we are going to use Convolutional Masks to transform an image and obtain different features of the image, and also we can see different effects on the image.
Convolutional Masks # Is a small matrix (in our case is a 9x9 matrix) which includes weightings (set of values that gives &amp;ldquo;relevance&amp;rdquo;) which are applied on pixel values in order to change the image and create different effects.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Kevin-Alvarez-taller-3/Normal-Map-Test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Kevin-Alvarez-taller-3/Normal-Map-Test/</guid><description>Testing Lighting and Normal Mapping # Background # Result # Extremely slow, start at your own risk.
Move your mouse to see how light interacts with the image.
Taken from Andor Saga at : https://openprocessing.org/sketch/1221468</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Kevin-Alvarez-taller-3/Procedural-Texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Kevin-Alvarez-taller-3/Procedural-Texturing/</guid><description>Procedural Texturing # Background # Is the method of generating textures by providing a set of parameters, these parameters are sent to an algorithm (in our case a shader) and it will create its own variations, using this method, computers generate data automatically, it is quite useful to make large textures , that wouldn&amp;rsquo;t be practical doing by hand, also reduces the need of storage for textures, and provides almost unlimited texture resolution.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Kevin-Alvarez-taller-3/Texture-Sampling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Kevin-Alvarez-taller-3/Texture-Sampling/</guid><description>Texture Sampling # Background # The main idea is to treat our image like a set of values, this allows us to sample it, or getting a finite number of values from said image, we then, can play with these values adding more effects, or altering the properties of our image, or even applying filters.
Luma # Luma allows us to see the light intensity in an image, by removing color, it shows areas with greater luminance in a whiter color, and a darker color in areas without light.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Kevin-Alvarez-taller-3/Texturing-and-Coloring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Kevin-Alvarez-taller-3/Texturing-and-Coloring/</guid><description>Texturing and Coloring # Background # We can use shaders as a texture, this allows us to give any 3d object a more dynamic appearance, shaders are simple scripts that allows us to map a color to each pixel of a given image, using parameters such as model coordinates. In this workshop we faced the challenge of mapping a shader on a non-primitive object, that is, using begin and end shape on p5, we faced some issues, the main one was that the shader was never applied on our shape, to solve this issue we needed to send the texture coordinates to a vertex shader, which is later sent to the fragment shader, this method allowed us to map our shader as a texture.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Taller-1/Taller1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Taller-1/Taller1/</guid><description>Taller 1 # Intoduction # An image kernel is a small matrix used to apply effects like the ones you might find in Photoshop or Gimp, such as blurring, sharpening, outlining or embossing. They&amp;rsquo;re also used in machine learning for &amp;lsquo;feature extraction&amp;rsquo;, a technique for determining the most important portions of an image. In this context the process is referred to more generally as &amp;ldquo;convolution&amp;rdquo;.
To see how they work, let&amp;rsquo;s start by inspecting a black and white image.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Taller-1/webgltest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Taller-1/webgltest/</guid><description> Resultados # p5-iframe markdown Conclusiones y Trabajo Futuro #</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Taller-2/3d-Brush/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Taller-2/3d-Brush/</guid><description>3d Brush and Rasterization # Is the process of taking an image, described in a vector graphics format and converting it into a series of pixels, dots, or almost any shape.
When these shapes are together, they will form the original image.
Vector graphics are a set of mathematical statements which place lines shapes in a 3d or 2d enviroment, being generally a group of mathematical curves, these are great for printing or image manipulation, even when enlarger they retain detail and quality, while raster graphics uses bitmaps to store information, this can limit the quality depending on resolution and file size.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Taller-2/Rasterization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Taller-2/Rasterization/</guid><description>Taller 2 # When a low-quality image is zoomed in or processed, the edges tend to become jagged or staggered. To solve this problem, we must apply smoothing to the figure. The process is carried out by generating a subdivision of the original pixels of the image. image in a greater number of pixels, to perform a smoothing of the edges with the use of barycentric coordinates, triangles are calculated on the original image.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Taller-2/WebCamTest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Taller-2/WebCamTest/</guid><description> Taller 2 # Introduccion # Contexto # Resultados # #</description></item></channel></rss>